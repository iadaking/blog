# 八大排序算法 

排序算法有内部排序和外部排序两种

内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

我们这里说说八大排序就是内部排序。

当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。

快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短

# 插入排序

### 直接插入排序

```java
import java.util.Arrays;

/**
 * 从第一个元素开始，该元素可以认为已经被排序
 * 取出下一个元素，在已经排序的元素序列中从后向前扫描
 * 如果该元素（已排序）大于新元素，将该元素移到下一位置
 * 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
 * 将新元素插入到该位置后
 * 重复步骤2~5
 * 基于移动 不是基于交换
 */

public class InsertSorttest {

    // 分类 --- 内部比较排序
    // 数据结构 ------ 数组
    // 最差时间复杂度 --- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
    // 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
    // 平均时间复杂度 ---- O(n^2)
    // 所需辅助空间 ------ O(1)
    // 稳定性 ----- 稳定

    private static void InsertSort(int[] a) {

        // 类似抓扑克牌排序
        for (int i = 1; i < a.length; i++) {
            // 右手抓到一张扑克牌
            int get = a[i];
            // 拿在左手上的牌总是排序好的
            int j = i - 1;
            // 将抓到的牌与手牌从右向左进行比较
            while (j >= 0 && a[j] > get) {
                // 如果该手牌比抓到的牌大,就将其右移
                a[j + 1] = a[j];
                j--;
            }
            // 直到该手牌比抓到的牌小(或二者相等),
            // 将抓到的牌插入到该手牌右边(相等元素的相对次序未变,所以插入排序是稳定的)
            a[j + 1] = get;
        }
    }

    public static void main(String[] args) {

        int[] a = {3, 1, 5, 7, 2, 4, 9, 6};

        System.out.println(Arrays.toString(a));

        InsertSort(a);

        System.out.println("排序后");
        System.out.println(Arrays.toString(a));
    }
}

```

## 二分插入排序

```java
import java.util.Arrays;

/**
 * 当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，
 * 所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。
 * 二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。
 */
public class ErFenInsertSort {

    // 分类 ------------- 内部比较排序
    // 数据结构 ---------- 数组
    // 最差时间复杂度 ---- O(n^2)
    // 最优时间复杂度 ---- O(nlogn)
    // 平均时间复杂度 ---- O(n^2)
    // 所需辅助空间 ------ O(1)
    // 稳定性 ------------ 稳定

    private static void erfenInsertSort(int[] A) {

        // 类似抓扑克牌排序
        for (int i = 1; i < A.length; i++)
        {
            // 右手抓到一张扑克牌
            int get = A[i];
            // 拿在左手上的牌总是排序好的,所以可以用二分法
            int left = 0;
            // 手牌左右边界进行初始化
            int right = i - 1;
            // 采用二分法定位新牌的位置
            while (left <= right)
            {
                int middle = (left + right) / 2;
                if (A[middle] > get) {
                    right = middle - 1;
                } else {
                    left = middle + 1;
                }
            }
            // 将欲插入新牌位置右边的牌整体向右移动一个单位
            for (int j = i - 1; j >= left; j--) {
                A[j + 1] = A[j];
            }
            // 将抓到的牌插入手牌
            A[left] = get;
        }
    }

    public static void main(String[] args) {
        int[] a = {3, 1, 5, 7, 2, 4, 9, 6};
        System.out.println(Arrays.toString(a));

        erfenInsertSort(a);

        System.out.println(Arrays.toString(a));
    }
}

```



## 希尔排序

**package** com.wenjie.sort;

/*

 * 希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。



　　希尔排序是基于插入排序的以下两点性质而提出改进方法的：

 

​       插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率

​       但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

 

　　希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

　　假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

 

　　希尔排序的代码如下：

 */

**public** **class** ShellSorttest {

​    // 分类-------------- 内部比较排序

​    // 数据结构 ----------数组

​    // 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)

​    // 最优时间复杂度 ----O(n)

​    // 平均时间复杂度 ---- 根据步长序列的不同而不同。

​    // 所需辅助空间 ------O(1)

​    // 稳定性------------ 不稳定 单次插入排序中是稳定的 不同序列插入排序中不一定

​    **public** **static** **void** main(String[] args) {

​        **int**[] a = {3,1,5,7,8,2,4,9,6};  

​        *shellSort*(a,a.length);  

​        *print*(a);  

​    }

 

​    **static** **void** print(**int** a[]){  

​         

​        **for**(**int** j= 0; j<a.length; j++){  

​        

​        System.*out*.println(a[j]);

​        }

​       

​    }  

 

**private** **static** **void** ShellInsertSort(**int**[] A,**int** n,**int** dk) {

 

​    **for** (**int** i = dk; i < n; i++)

​    {

​        **int** j = i - dk;

​        **int** get = A[i];

​        **while** ((j >= 0) && (A[j]> get))

​        {

​            A[j + dk] = A[j];

​            j = j - dk;

​        }

​        A[j + dk] = get;

​    }

​                   // 递减增量

}

​    

 

/** 

 * 先按增量d（n/2,n为要排序数的个数进行希尔排序

 * ​

 */  

**static** **void** shellSort(**int** a[], **int** n){  

 

​    **int** dk = n/2;  

​    **while**( dk >= 1  ){  

​        *ShellInsertSort*(a,n, dk);  

​        dk = dk/2;  

​    }  

} 

}

## 冒泡排序

**package** com.wenjie.sort;

/*

 * 基本思想：



在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，

让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

 */

**public** **class** PPSorttest {

​    // 分类-------------- 内部比较排序

​    // 数据结构---------- 数组

​    // 最差时间复杂度 ----O(n^2)

​    // 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)

​    // 平均时间复杂度 ----O(n^2)

​    // 所需辅助空间 ------O(1)

​    // 稳定性------------ 稳定

​    **static** **void** exchange(**int** A[], **int** i, **int** j)        // 交换A[i]和A[j]

​    {

​        **int** temp = A[i];

​        A[i] = A[j];

​        A[j] = temp;

​    }

 

​    **public** **static** **void** main(String[] args) {

​        // **TODO** Auto-generated method stub

​        **int** A[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; 

​        *popSort*(A,A.length);

​        System.*out*.println("冒泡排序结果：");

​        **for** (**int** i = 0; i < A.length; i++)

​        {

​         System.*out*.printf("%d ", A[i]);

​        }

​        

​    }

​    **private**  **static** **void** popSort(**int** A[],**int** n){

​        **for** (**int** j = 0; j < n; j++)            // 每次最大元素就像气泡一样"浮"到数组的最后

​        {

​            **for** (**int** i = 0; i < n-1-j; i++)    // 依次比较相邻的两个元素,使较大的那个向后移

​            {

​                **if** (A[i] > A[i + 1])            // 如果条件改成A[i]>= A[i + 1],则变为不稳定的排序算法

​                {

​                    *exchange*(A, i, i + 1);       

​                }

​            }

​        }

​        

​        

​                       

​        }

​        

​    }

方法二：

​    **public** **static** **void** bubbleSort() {

​        **int** a[] = { 49, 38, 65, 97, 76, 13, 27, 49 };

​        **for** (**int** i = a.length - 1; i >= 0; i--) {

​            **for** (**int** j = 0; j < i; j++) {

​                **if** (a[j] > a[j + 1]) {

​                   **int** k = a[j];

​                   a[j]= a[j + 1];

​                   a[j+ 1] = k;

​                }

​            }

​        }

​        **for** (**int** i = 0; i < a.length; i++) {

​            System.*out*.print(a[i] + ", ");

​        }

​    }

/*冒泡排序的优化

 * 1．设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。

 * 由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可

/*

​    /**

​     * 设置标志位 若这一趟都没有改变数据 那么就 break

​     */

​    **public** **static** **void** ppSort2(){

​     **boolean** flag = **true**;

​        **int** a[] = { 49, 38, 65, 97, 76, 13, 27, 49 };

​        **int** n = a.length;

​            **for** (**int** i = 0; i < n-1; i++) {

​                flag= **true**;

​                **for** (**int** j = 0; j < n-1-i; j++) {

​                   **if** (a[j]>a[j+1]) {

​                       *exchange*(a,j,j+1);

​                       flag= **false**;

​                   }

​                }

​                **if** (flag) {

​                   **break**;

​                }

​                System.*out*.println("我是第"+i+"趟排序");

​        }

​        *printArray*(a);

​    }

2．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,

我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) ,

 从而使排序趟数几乎减少了一半。

 

改进后的算法实现为:

void Bubble_2 ( int r[],int n){  

int low = 0;   

int high= n -1; //设置变量的初始值  

int tmp,j;  

while (low < high) {  

​    for (j= low; j< high; ++j) //正向冒泡,找到最大者  

​        if (r[j]> r[j+1]) {  

​            tmp = r[j];r[j]=r[j+1];r[j+1]=tmp;  

​        }  

​    --high;                 //修改high值, 前移一位 

​    for ( j=high; j>low; --j) //反向冒泡,找到最小者  

​        if (r[j]<r[j-1]) {  

​            tmp = r[j];r[j]=r[j-1];r[j-1]=tmp;  

​        } 

​    ++low;                  //修改low值,后移一位 

}   

}   */

## **鸡尾酒排序**

**package** com.wenjie.sort;

/**

 * 对冒泡排序的一种改进 一趟排序中  分别向前向后都排序

 * **@author** Administrator鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。

 * 此算法与冒泡排序的不同处在于从低到高然后从高到低，

 * 而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。

 *

 */

**public** **class** JiWeiJiuSorttest

{

​    // 分类-------------- 内部比较排序

​    // 数据结构---------- 数组

​    // 最差时间复杂度 ----O(n^2)

​    // 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)

​    // 平均时间复杂度 ----O(n^2)

​    // 所需辅助空间 ------O(1)

​    // 稳定性------------ 稳定

​    **static** **void** exchange(**int** A[], **int** i, **int** j)        // 交换A[i]和A[j]

​    {

​        **int** temp = A[i];

​        A[i] = A[j];

​        A[j] = temp;

​    }

 

​    **public** **static** **void** main(String[] args) {

​        // **TODO** Auto-generated method stub

​        **int** A[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; 

​        *popSortjiweijiu*(A,A.length);

​        System.*out*.println("鸡尾酒排序结果：");

​        **for** (**int** i = 0; i < A.length; i++)

​        {

​         System.*out*.printf("%d ", A[i]);

​        }

​        

​    }

​    **private**  **static** **void** popSortjiweijiu(**int** A[],**int** n){

​        //定义了排序躺数

​        **int** left = 0;

​        **int** right = n-1;

​        

​        **while** (left<right) {

​            **for** (**int** i = left; i < right;i++)  // 前半轮,将最大元素放到后面

​                **if** (A[i] > A[i + 1]) 

​                {

​                    *exchange*(A, i, i + 1);

​                }

​            right--;

​            **for** (**int** i = right; i > left;i--)  // 后半轮,将最小元素放到前面

​                **if** (A[i - 1] > A[i]) 

​                {

​                    *exchange*(A, i - 1, i);

​                }

​            left++;                                

​        }

​    }

 

}

## **选择排序(Selection Sort)**

 **package** com.wenjie.sort;

/*

 * 首先在未排序序列中找到最小（大）元素，

 * 存放到排序序列的起始位置；

 * 然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。代码如下：

 */

**public** **class** SelectSorttest {

 

​    // 分类-------------- 内部比较排序

​    // 数据结构---------- 数组

​    // 最差时间复杂度 ----O(n^2)

​    // 最优时间复杂度 ----O(n^2)

​    // 平均时间复杂度 ----O(n^2)

​    // 所需辅助空间 ------O(1)

​    // 稳定性------------ 不稳定 发生在与最小元素交换的情况下

 

​    **static** **void** exchange(**int** A[], **int** i, **int** j)        // 交换A[i]和A[j]

​    {

​        **int** temp = A[i];

​        A[i] = A[j];

​        A[j] = temp;

​    }

​    **public** **static** **void** main(String[] args) {

​        **int** A[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; 

​        *selectSort*(A,A.length);

​        System.*out*.println("选择排序的排序结果：");

​        **for** (**int** i = 0; i < A.length; i++)

​        {

​         System.*out*.printf("%d ", A[i]);

​        }

​        

​        

​    }

 

​    **private** **static** **void** selectSort(**int**[] A,**int** n){

​        

​        **for** (**int** i = 0; i < n-1; i++)                // 已排序序列的末尾

​        {

​            **int** min = i;    

​            **for** (**int** j = i + 1; j < n; j++)        // 未排序序列

​            {

​                **if** (A[j] < A[min])// 依次找出未排序序列中的最小值,存放到已排序序列的末尾

​                {

​                    min = j;

​                }

​            }

​            **if** (min != i)

​            {

​                *exchange*(A,min, i);    // 该操作很有可能把稳定性打乱,所以选择排序是不稳定的排序算法

​            }

​        }

​        

​    }

​    

}

**简单选择排序的改进——****二元选择排序**

简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。具体实现如下：

1. void SelectSort(int r[],int n) {  
2. ​    int i ,j , min ,max, tmp;  
3. ​    for (i=1 ;i <= n/2;i++) {    
4. ​        // 做不超过n/2趟选择排序   
5. ​        min = i; max = i ; //分别记录最大和最小关键字记录位置  
6. ​        for (j= i+1; j<= n-i; j++) {  
7. ​            if (r[j] > r[max]) {   
8. ​                max = j ; continue ;   
9. ​            }    
10. ​            if (r[j]< r[min]) {   
11. ​                min = j ;   
12. ​            }     
13. ​      }    
14. ​      //该交换操作还可分情况讨论以提高效率  
15. ​      tmp = r[i-1]; r[i-1] = r[min]; r[min] = tmp;  
16. ​      tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp;   
17. ​
18. ​    }   
19. }  

### 归并排序

**package** com.wenjie.sort;

/*

 * 归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。



　　归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。

 

　　归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作,归并操作步骤如下：

 

​    申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列

​    设定两个指针，最初位置分别为两个已经排序序列的起始位置

​    比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置

​    重复步骤3直到某一指针到达序列尾

​    将另一序列剩下的所有元素直接复制到合并序列尾

 

 */

**public** **class** MergeSorttest {

​    // 分类-------------- 内部比较排序

​    // 数据结构---------- 数组

​    // 最差时间复杂度 ----O(nlogn)

​    // 最优时间复杂度 ----O(nlogn)

​    // 平均时间复杂度 ----O(nlogn)

​    // 所需辅助空间 ------O(n)

​    // 稳定性------------ 稳定

 

​    **private** **static** **int** *L*[];

​    **private** **static** **int** *R*[];

 

​    **public** **static** **void** main(String[] args) {

​            **int** A1[] = { 6, 5, 3, 1, 8, 7, 2, 4};    // 从小到大归并排序

​            **int** A2[] = { 6, 5, 3, 1, 8, 7, 2, 4};    

​            **int** n1 = A1.length;

​            **int** n2 = A2.length;

​            

​           

​            

​            *mergesort_recursion*(A1,0, n1 - 1);       // 递归实现

​            *mergesort_iteration*(A2,0, n2 - 1);       // 非递归实现

​            System.*out*.printf("递归实现的归并排序结果：");

​            **for** (**int** i = 0; i < n1; i++)

​            {

​             System.*out*.printf("%d ",A1[i]);

​            }

​            System.*out*.printf("\n");

​            System.*out*.printf("非递归实现的归并排序结果：");

​            **for** (**int** i = 0; i < n2; i++)

​            {

​             System.*out*.printf("%d ", A2[i]);

​            }

​            System.*out*.printf("\n");

​           

​    }

 

​    **private** **static** **void** mergesort_iteration(**int**[] A2, **int** left, **int** right) // 非递归(迭代)实现的归并排序(自底向上)

​    {

​        **int** low, middle, high;    // 子数组索引,前一个为A[low...middle],后一个子数组为A[middle+1...high]

​        **for** (**int** size = 1; size <= right -left; size *= 2) // 子数组的大小初始为1,每轮翻倍

​        {

​            low = left;

​            **while** (low + size - 1 <= right - 1)// 后一个子数组存在(需要归并)

​            {

​                middle = low + size - 1;    

​                high = middle + size;        

​                **if** (high > right)            // 后一个子数组大小不足size

​                    high = right;

​                *merge*(A2,low, middle, high);

​                low = high + 1;               // 前一个子数组索引向后移动

​            }

​        }

​    }

 

​    **private** **static** **void** mergesort_recursion(**int**[] A1, **int** left, **int** right){ // 递归实现的归并排序(自顶向下)

​    

​        **int** middle = (left + right) / 2;

​        **if** (left < right)          // 当待排序的序列长度为1时(left == right)，递归“开始回升”

​        {

​            *mergesort_recursion*(A1,left, middle);

​            *mergesort_recursion*(A1,middle + 1, right);

​            *merge*(A1,left, middle, right);

​        }

​    }

 

​    

 

​    **static** **void** print(**int** a[]){  

​         

​        **for**(**int** j= 0; j<a.length; j++){  

​        

​        System.*out*.println(a[j]);

​        }

​       

​    }  

 

​    **private** **static** **void** merge(**int**[] A, **int** left, **int** middle, **int** right) {

​        // **TODO** Auto-generated method stub

​        **int** n1 = middle - left + 1;     // 两个数组的大小

​        **int** n2 = right - middle;

​        **for** (**int** i = 0; i < n1; i++)    // 把两部分分别拷贝到两个数组中

​            *L*[i] = A[left + i];

​        **for** (**int** j = 0; j < n2; j++)

​            *R*[j] = A[middle + j + 1];

​       // L[n1] = INT_MAX;                // 使用无穷大作为哨兵值放在子数组的末尾

​       // R[n2] = INT_MAX;                // 这样可以免去检查某个子数组是否已读完的步骤

​        **int** i = 0;

​        **int** j = 0;

​        **for** (**int** k = left; k <= right; k++) // 依次比较两个子数组中的值，每次取出更小的那一个放入原数组

​        {

​            **if** (*L*[i] <= *R*[j]) 

​            {

​                A[k] = *L*[i];

​                i++;

​            }

​            **else**

​            {

​                A[k] = *R*[j];

​                j++;

​            }

​        }

​    }

}

 

# 堆排序

堆排序是一种树形选择排序，是对直接选择排序的有效改进。

**基本思想：**

堆的定义如下：具有n个元素的序列（k1,k2,...,kn),当且仅当满足

时称之为堆。由堆的定义可以看出，**堆顶元素**（即第一个元素）必为最小项（小顶堆）。
若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：

（a）大顶堆序列：（96, 83,27,38,11,09)

  (b)  小顶堆序列：（12，36，24，85，47，30，53，91）

![IMG_257](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

 

初始时把要排序的n个数的序列看作是一棵**顺序存储的二叉树（一维数组存储二叉树）**，调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为**堆排序**。

因此，实现堆排序需解决两个问题：
\1. 如何将n 个待排序的数建成堆；
\2. 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。

首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。
调整小顶堆的方法：

1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。

2）将根结点与左、右子树中较小元素的进行交换。

3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法（2）.

4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法（2）.

5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。

称这个自根结点到叶子结点的调整过程为筛选。如图：
再讨论对n 个元素初始建堆的过程。
建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。

1）n 个结点的完全二叉树，则最后一个结点是第![IMG_259](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)个结点的子树。

2）筛选从第![IMG_260](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)个结点为根的子树开始，该子树成为堆。

3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。

如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）
![IMG_261](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

![IMG_262](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

 

 

**package** com.wenjie.sort;

/*

 * 初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。



因此，实现堆排序需解决两个问题：

\1. 如何将n 个待排序的数建成堆；

\2. 输出堆顶元素后，怎样调整剩余n-1个元素，使其成为一个新堆。

 */

 

//本示例是   分为两步  第一步建堆 ，从节点n/2-1开始调整堆 然后 在节点处进行递归调整堆  每次传入largest再递归调整 递归过程中以heapsize是否越界为递归停止条件

//第二步是 将堆顶 0节点元素和最后一个元素 change 0 和 n-1 将heapsize-1 然后传入节点0每次从节点0开始调整堆  知道不满足heapsize条件  跳出递归

**public** **class** HeapSorttest {

​    // 分类 --------------内部比较排序

​    // 数据结构---------- 数组

​    // 最差时间复杂度 ----O(nlogn)

​    // 最优时间复杂度 ----O(nlogn)

​    // 平均时间复杂度 ----O(nlogn)

​    // 所需辅助空间 ------O(1)

​    // 稳定性------------ 不稳定

​    **static** **int** *heapsize*;

​    **public** **static** **void** main(String[] args) {

​        // **TODO** Auto-generated method stub

​        **int** A[] = { 15, 2, 39, 4, 27, 46, 11, 53, 78 };// 从小到大堆排序

​        **int** n = A.length;

​        *heapsort*(A,n);

​        System.*out*.printf("堆排序结果：");

​        **for** (**int** i = 0; i < n; i++)

​        {

​         System.*out*.printf("%d ", A[i]);

​        }

​        System.*out*.printf("\n");

​        

​    }

​    /*

​     * 堆排序总函数

​     */

​    **private** **static** **void** heapsort(**int**[] A, **int** n) {

​        // **TODO** Auto-generated method stub

​        *buildheap*(A,n);

​        **for** (**int** i = n - 1; i >= 1; i--)

​        {

​            *exchange*(A,0, i); // 将堆顶元素(当前最大值)与堆的最后一个元素互换(该操作很有可能把后面元素的稳定性打乱,所以堆排序是不稳定的排序算法)

​            *heapsize*--;                     // 从堆中去掉最后一个元素

​            *heapify*(A,0);                  // 从新的堆顶元素开始进行堆调整

​        }

​    }

​    /*

​     * 堆排序的堆调整

​     */

​    **private** **static** **void** heapify(**int**[] A, **int** i) {

​        // **TODO** Auto-generated methodstub  因为是一维数组表示 所以左右孩子用数组下标表示

​        **int** leftchild = 2 * i + 1;          // 左孩子索引

​        **int** rightchild = 2 * i + 2;         // 右孩子索引

​        **int** largest;                        // 选出当前结点与左右孩子之中的最大值

​        **if** (leftchild < *heapsize* && A[leftchild] > A[i])

​            largest = leftchild;

​        **else**

​            largest = i;

​        **if** (rightchild < *heapsize* && A[rightchild] > A[largest])

​            largest = rightchild;

​        **if** (largest != i)                    

​        {

​            *exchange*(A,i, largest);        // 把当前结点和它的最大(直接)子节点进行交换

​            *heapify*(A,largest);            // 递归调用，继续从当前结点向下进行堆调整

​        }

​    }

​    /*

​     * 堆排序的建堆过程

​     */

​    **private** **static** **void** buildheap(**int**[] A, **int** n) {

​        // **TODO** Auto-generated method stub

​        *heapsize* = n;

​        **for** (**int** i = *heapsize* / 2 - 1; i >= 0; i--) // 对每一个非叶结点//因为下标从零开始   所以是取膜减一

​            *heapify*(A,i);                  // 不断的堆调整

​    }

​    **static** **void** exchange(**int** A[], **int** i, **int** j)    // 交换A[i]和A[j]

​    {

​        **int** temp = A[i];

​        A[i] = A[j];

​        A[j] = temp;

​    }

 

}

自己写的方法：

**package** com.wenjie.sort;

 

**public** **class** HeapSort {

 

​    **public** **static** **void** main(String[] args) {

​        // **TODO** Auto-generated method stub

​        **int** arr[] = {3,5,4,1,2,7};

​        *heapSort*(arr);

​        *printArray*(arr);

​    }

​    **public** **static** **void** printArray(**int**[] array) {  

​        System.*out*.print("{");  

​        **for** (**int** i = 0; i < array.length; i++) {  

​            System.*out*.print(array[i]);  

​            **if** (i < array.length - 1) {  

​                System.*out*.print(",");  

​            } 

​        } 

​        System.*out*.println("}");  

​    }

​    **public** **static** **void** heapSort(**int**[] array) {

​        *buildHeap*(array);// 构建堆

​        **int** n = array.length;

​        **int** i = 0;

​        **for** (i = n - 1; i >= 1; i--) {

​            *swap*(array, 0, i);

​            *heapify*(array, 0, i);

​        }

​    }

​    **private** **static** **void** heapify(**int**[] array, **int** tx, **int** max) {

​        // **TODO** Auto-generated method stub

​        **int** left = tx*2+1;

​        **int** right = tx*2+2;

​        **int** large = tx;

​        **if** (left<max && array[left]>array[large]) {

​            large= left;

​        }

​        **if** (right<max && array[right]>array[large]) {

​            large = right;

​        }

​        **if** (large!=tx) {

​            *swap*(array, tx, large);

​            *heapify*(array, large, max);

​        }

​    }

​    **private** **static** **void** swap(**int**[] array, **int** i, **int** j) {

​        // **TODO** Auto-generated method stub

​        **int** temp = array[i];

​        array[i]= array[j];

​        array[j]= temp;

​    }

​    **private** **static** **void** buildHeap(**int**[] array) {

​        // **TODO** Auto-generated method stub

​        **int** n = array.length;// 数组中元素的个数

​        **for** (**int** i = n / 2 - 1; i >= 0; i--)

​            *heapify*(array, i, n);

​    }

}

# 快速排序

**package** com.wenjie.sort;

/*

 * 快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：



​    从序列中挑出一个元素，作为"基准"(pivot).

​    把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。

​    对每个分区递归地进行步骤1~3，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。

 

 

快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。

 

　　比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。

 */

**public** **class** QuickSortTest {

​    // 分类------------ 内部比较排序

​    // 数据结构 ---------数组

​    // 最差时间复杂度 ---- 每次选取的基准都是最大的元素（或者每次都是最小），导致每次只划分出了一个子序列，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)

​    // 最优时间复杂度 ---- 每次选取的基准都能使划分均匀，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)

​    // 平均时间复杂度 ----O(nlogn)

​    // 所需辅助空间 ------O(logn)～O(n),主要是递归造成的栈空间的使用(用来保存left和right等局部变量),取决于递归树的深度

​    //                     一般为O(logn),最差为O(n)（基本有序的情况）

​    // 稳定性 ----------不稳定

​    **static** **void** exchange(**int** A[], **int** i, **int** j)        // 交换A[i]和A[j]

​    {

​        **int** temp = A[i];

​        A[i] = A[j];

​        A[j] = temp;

​    }

​    **public** **static** **void** main(String[] args) {

​        // **TODO** Auto-generated method stub

​         **int** A[] = { 5, 2, 9, 4, 7, 6, 1, 3,8 };// 从小到大快速排序

​            **int** n = A.length;

​            *quicksort*(A,0, n - 1);

​            System.*out*.printf("快速排序结果：");

​            **for** (**int** i = 0; i < n; i++)

​            {

​             System.*out*.printf("%d ",A[i]);

​            }

​            System.*out*.printf("\n");

​            

​    }

第一种思路：固定枢纽  固定为左端 固定为右端（但是在部分排序下 效果很差）

​    **private** **static** **void** quicksort(**int**[] A, **int** left, **int** right) {

​        // **TODO** Auto-generated method stub

​        **int** pivot_index;                        // 基准的索引

​        **if** (left < right)

​        {

​            pivot_index = *partition*(A, left, right);

​            *quicksort*(A,left, pivot_index-1);

​            *quicksort*(A,pivot_index+1, right);

​        }

​    }

 

​    **private** **static** **int** partition(**int**[] A, **int** left, **int** right) {//分割函数

​        // **TODO** Auto-generated method stub

​        **int** pivot = A[right];  // 选择最后一个元素作为基准

​        **int** tail = left -1;

​                                          // tail为小于基准的子数组最后一个元素的索引

​        **for** (**int** i = left; i < right;i++)       // 遍历基准以外的其他元素

​        {

​            **if** (A[i] <= pivot)                   // 把小于等于基准的元素放到前一个子数组中

​            {

​                tail++;

​                *exchange*(A,tail, i);

​            }

​        }

​        *exchange*(A,tail + 1, right);            // 最后把基准放到前一个子数组的后边,剩下的子数组既是大于基准的子数组

​                                               // 该操作很有可能把后面元素的稳定性打乱,所以快速排序是不稳定的排序算法

​        **return** tail + 1;                         // 返回基准的索引                                             

​    }

 

}

 

​    **public** **static** **void** quicksort(**int** n[], **int** left, **int** right) {

​        **int** dp;

​        **if** (left < right) {

​            dp= *partition*(n, left, right);

​            *quicksort*(n, left, dp - 1);

​            *quicksort*(n, dp + 1, right);

​        }

​    }

 

​    **public** **static** **int** partition(**int**[] n, **int** left, **int** right) {

​        **int** pivotkey = n[left];

​        // 枢轴选定后永远不变，最终在中间，前小后大

​        **while** (left < right) {

​            **while** (left < right && n[right] >= pivotkey)

​                --right;

​            // 将比枢轴小的元素移到低端，此时right位相当于空，等待低位比pivotkey大的数补上

​            n[left]= n[right];

​            **while** (left < right && n[left] <= pivotkey)

​                ++left;

​            // 将比枢轴大的元素移到高端，此时left位相当于空，等待高位比pivotkey小的数补上

​            n[right]= n[left];

​        }

​        // 当left == right，完成一趟快速排序，此时left位相当于空，等待pivotkey补上

​        n[left]= pivotkey;

​        **return** left;

​    }

​    **public** **static** **void** quicksortMain(){

​        **int** array[] = { 9, 5, 4, 8, 7, 3, 2,10 };

​        *quicksort*(array, 0, array.length-1);

​        *printArray*(array);

​    }

​    第二种方法：三个数取中：

```
import java.util.*;
```

```
public class QuickSort {
```

```
    public int[] quickSort(int[] A, int n) {
```

```
        //快速排序
```

```
 
```

```
        qSort(A,0,n-1);
```

```
 
```

```
        return A;
```

```
 
```

```
    }
```

```
    public void qSort(int[] A,int left,int right){
```

```
 
```

```
         //枢轴
```

```
        int pivot;
```

```
        if(left<right){
```

```
 
```

```
            pivot = partition(A,left,right);
```

```
 
```

```
            qSort(A,left,pivot-1);
```

```
            qSort(A,pivot+1,right);
```

```
 
```

```
        }      
```

```
 
```

```
    }
```

```
 
```

```
    //优化选取一个枢轴，想尽办法把它放到一个位置，使它左边的值都比它小，右边的值都比它大
```

```
    public int partition(int[] A,int left,int right){
```

```
 
```

```
        //优化选取枢轴，采用三数取中的方法
```

```
        int pivotKey = median3(A,left,right);
```

```
        //从表的俩边交替向中间扫描
```

```
        //枢轴用pivotKey给备份了
```

```
        while(left<right){
```

```
           while(left<right&&A[right]>=pivotKey){
```

```
               right--;
```

```
           }
```

```
            //用替换方式，因为枢轴给备份了，多出一个存储空间
```

```
            A[left]=A[right];
```

```
           while(left<right&&A[left]<=pivotKey){
```

```
               left++;
```

```
           }
```

```
           A[right]=A[left];
```

```
 
```

```
        }
```

```
 
```

```
        //把枢轴放到它真正的地方
```

```
        A[left]=pivotKey;
```

```
        return left;
```

```
    }
```

```
    //三数取中
```

```
    public int median3(int[] A,int left,int right){
```

```
 
```

```
        int mid=(right-left)/2;
```

```
        if(A[left]>A[right]){
```

```
            swap(A,left,right);
```

```
        }
```

```
        if(A[mid]>A[left]){
```

```
            swap(A,mid,left);
```

```
        }
```

```
        if(A[mid]>A[right]){
```

```
            swap(A,mid,right);
```

```
        }
```

```
 
```

```
        return A[left];
```

```
    }
```

```
 
```

```
    public void swap(int[] A,int i,int j){
```

```
        int temp =A[i];
```

```
        A[i]=A[j];
```

```
        A[j]=temp;
```

```
    }
```

```
}
```

# 三种快排及四种优化方式 

2016-08-10 20:46 7504人阅读 [评论](http://blog.csdn.net/hacker00011000/article/details/52176100#comments)(3) [收藏](javascript:void(0);) [举报](http://blog.csdn.net/hacker00011000/article/details/52176100#report) 

版权声明：本文为博主原创文章，未经博主允许不得转载。

**1****、快速排序的基本思想：** 
快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。

**2****、快速排序的三个步骤：** 
(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot） 
(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大 
(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。

**3****、选择基准的方式：** 
对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。

最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列

**我们介绍三种选择基准的方法：(3****种)**

**方法(1)****：固定位置**

思想：取序列的第一个或最后一个元素作为基准

基本的快速排序

```
int SelectPivot(int arr[],int low,int high)  
```

```
{  
```

```
    return arr[low];//选择选取序列的第一个元素作为基准  
```

```
}  
```

注意：基本的快速排序选取第一个或最后一个元素作为基准。但是，这是一直很不好的处理方法。

测试数据：

![IMG_256](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

测试数据分析：如果输入序列是随机的，处理时间可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为起泡排序，时间复杂度为Θ(n^2)。而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为枢纽元是非常糟糕的，为了避免这个情况，就引入了下面两个获取基准的方法。

**方法(2)****：随机选取基准**

引入的原因：在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴

思想：取待排序列中任意一个元素作为基准

随机化算法

```
/*随机选择枢轴的位置，区间在low和high之间*/  
```

```
int SelectPivotRandom(int arr[],int low,int high)  
```

```
{  
```

```
    //产生枢轴的位置  
```

```
    srand((unsigned)time(NULL));  
```

```
    int pivotPos = rand()%(high - low) + low;  
```

```
 
```

```
    //把枢轴位置的元素和low位置元素互换，此时可以和普通的快排一样调用划分函数  
```

```
    swap(arr[pivotPos],arr[low]);  
```

```
    return arr[low];  
```

```
}  
```

测试数据：

![IMG_257](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg)

测试数据分析：:这是一种相对安全的策略。由于枢轴的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。一位前辈做出了一个精辟的总结：“随机化快速排序可以满足一个人一辈子的人品需求。”

**方法(3)****：三数取中（median-of-three****）**

**引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2****），要缓解这种情况，就引入了三数取中选取枢轴**

分析：最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约14%的比较次数

**举例：待排序序列为：8 1 4 9 6 3
5 2 7 0** 
**左边为：8****，右边为0****，中间为6.** 
**我们这里取三个数排序后，中间那个数作为枢轴，则枢轴为6**

注意：在选取中轴值时，可以从由左中右三个中选取扩大到五个元素中或者更多元素中选取，一般的，会有（2t＋1）平均分区法（median-of-(2t+1)，三平均分区法英文为median-of-three）。

具体思想：对待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。

即：采用三数取中，并用0下标元素存储枢轴。

```
/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/  
```

```
int SelectPivotMedianOfThree(int arr[],int low,int high)  
```

```
{  
```

```
    int mid = low + ((high - low) >> 1);//计算数组中间的元素的下标  
```

```
 
```

```
    //使用三数取中法选择枢轴  
```

```
    if (arr[mid] > arr[high])//目标: arr[mid] <= arr[high]  
```

```
    {  
```

```
        swap(arr[mid],arr[high]);  
```

```
    }  
```

```
    if (arr[low] > arr[high])//目标: arr[low] <= arr[high]  
```

```
    {  
```

```
        swap(arr[low],arr[high]);  
```

```
    }  
```

```
    if (arr[mid] > arr[low]) //目标: arr[low] >= arr[mid]  
```

```
    {  
```

```
        swap(arr[mid],arr[low]);  
```

```
    }  
```

```
    //此时，arr[mid] <= arr[low] <= arr[high]  
```

```
    return arr[low];  
```

```
    //low的位置上保存这三个位置中间的值  
```

```
    //分割时可以直接使用low位置的元素作为枢轴，而不用改变分割函数了  
```

```
} 
```

测试数据：

![IMG_258](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

测试数据分析：使用**三数取中**选择枢轴优势还是很明显的，但是还是处理不了重复数组

**4****、四种优化方式：**

**优化1****：当待排序序列的长度分割到一定大小后，使用插入排序**

原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排

截止范围：待排序序列长度N = 10，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形。摘自《数据结构与算法分析》Mark Allen Weiness 著

```
if (high - low + 1 < 10)  
```

```
{  
```

```
    InsertSort(arr,low,high);  
```

```
    return;  
```

```
}//else时，正常执行快排  
```

测试数据：

![IMG_259](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg)

测试数据分析：针对随机数组，使用三数取中选择枢轴+插排，效率还是可以提高一点，真是针对已排序的数组，是没有任何用处的。因为待排序序列是已经有序的，那么每次划分只能使待排序序列减一。此时，插排是发挥不了作用的。所以这里看不到时间的减少。另外，三数取中选择枢轴+插排还是不能处理重复数组

**优化2****：在一次分割结束后，可以把与Key****相等的元素聚在一起，继续下次分割时，不用再对与key****相等元素分割**

举例：

待排序序列 1 4 6 7 6 6 7 6 8 6

三数取中选取枢轴：下标为4的数6

转换后，待分割序列：6 4 6 7 1 6 7 6 8 6

```
         枢轴key：6
```

本次划分后，未对与key元素相等处理的结果：1 4 6 6 7 6 7 6 8 6

下次的两个子序列为：1 4 6 和 7 6 7 6 8 6

本次划分后，对与key元素相等处理的结果：1 4 6 6 6 6 6 7 8 7

下次的两个子序列为：1 4 和 7 8 7

经过对比，我们可以看出，在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少

**具体过程：在处理过程中，会有两个步骤** 
**第一步，在划分过程中，把与key****相等元素放入数组的两端** 
**第二步，划分结束后，把与key****相等的元素移到枢轴周围**

举例：

待排序序列 1 4 6 7 6 6 7 6 8 6

三数取中选取枢轴：下标为4的数6

转换后，待分割序列：6 4 6 7 1 6 7 6 8 6

```
         枢轴key：6
```

第一步，在划分过程中，把与key相等元素放入数组的两端 
结果为：6 4 1 6(枢轴) 7 8 7 6 6 6

此时，与6相等的元素全放入在两端了

第二步，划分结束后，把与key相等的元素移到枢轴周围

结果为：1 4 66(枢轴) 6 6 6 7 8 7

此时，与6相等的元素全移到枢轴周围了

之后，在1 4 和 7 8 7两个子序列进行快排

```
void QSort(int arr[],int low,int high)  
```

```
{  
```

```
    int first = low;  
```

```
    int last = high;  
```

```
 
```

```
    int left = low;  
```

```
    int right = high;  
```

```
 
```

```
    int leftLen = 0;  
```

```
    int rightLen = 0;  
```

```
 
```

```
    if (high - low + 1 < 10)  
```

```
    {  
```

```
        InsertSort(arr,low,high);  
```

```
        return;  
```

```
    }  
```

```
 
```

```
    //一次分割  
```

```
    int key = SelectPivotMedianOfThree(arr,low,high);//使用三数取中法选择枢轴  
```

```
 
```

```
    while(low < high)  
```

```
    {  
```

```
        while(high > low && arr[high] >= key)  
```

```
        {  
```

```
            if (arr[high] == key)//处理相等元素  
```

```
            {  
```

```
                swap(arr[right],arr[high]);  
```

```
                right--;  
```

```
                rightLen++;  
```

```
            }  
```

```
            high--;  
```

```
        }  
```

```
        arr[low] = arr[high];  
```

```
        while(high > low && arr[low] <= key)  
```

```
        {  
```

```
            if (arr[low] == key)  
```

```
            {  
```

```
                swap(arr[left],arr[low]);  
```

```
                left++;  
```

```
                leftLen++;  
```

```
            }  
```

```
            low++;  
```

```
        }  
```

```
        arr[high] = arr[low];  
```

```
    }  
```

```
    arr[low] = key;  
```

```
 
```

```
    //一次快排结束  
```

```
    //把与枢轴key相同的元素移到枢轴最终位置周围  
```

```
    int i = low - 1;  
```

```
    int j = first;  
```

```
    while(j < left && arr[i] != key)  
```

```
    {  
```

```
        swap(arr[i],arr[j]);  
```

```
        i--;  
```

```
        j++;  
```

```
    }  
```

```
    i = low + 1;  
```

```
    j = last;  
```

```
    while(j > right && arr[i] != key)  
```

```
    {  
```

```
        swap(arr[i],arr[j]);  
```

```
        i++;  
```

```
        j--;  
```

```
    }  
```

```
    QSort(arr,first,low - 1 - leftLen);  
```

```
    QSort(arr,low + 1 + rightLen,last);  
```

```
}  
```

测试数据：

![IMG_260](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

测试数据分析：**三数取中选择枢轴****+****插排+****聚集相等元素**的组合，效果竟然好的出奇。

原因：在数组中，如果有相等的元素，那么就可以减少不少冗余的划分。这点在重复数组中体现特别明显啊。

其实这里，插排的作用还是不怎么大的。

**优化3****：优化递归操作**

快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化

优点：如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。

```
void QSort(int arr[],int low,int high)  
```

```
{   
```

```
    int pivotPos = -1;  
```

```
    if (high - low + 1 < 10)  
```

```
    {  
```

```
        InsertSort(arr,low,high);  
```

```
        return;  
```

```
    }  
```

```
    while(low < high)  
```

```
    {  
```

```
        pivotPos = Partition(arr,low,high);  
```

```
        QSort(arr,low,pivot-1);  
```

```
        low = pivot + 1;  
```

```
    }  
```

```
}  
```

**注意：在第一次递归后，low****就没用了，此时第二次递归可以使用循环代替**

测试数据：

![IMG_261](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image007.jpg)

测试数据分析：其实这种优化编译器会自己优化，相比不使用优化的方法，时间几乎没有减少

**优化4****：使用并行或多线程处理子序列（略）**

所有的数据测试：

![IMG_262](file:///C:/Users/kwd/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

**概括：这里效率最好的快排组合 ****是：三数取中+****插排+****聚集相等元素,****它和STL****中的Sort****函数效率差不多**

**注意：由于测试数据不稳定，数据也仅仅反应大概的情况。如果时间上没有成倍的增加或减少，仅仅有小额变化的话，我们可以看成时间差不多。**

参考文献

<http://blog.sina.com.cn/s/blog_5a3744350100jnec.html>

<http://www.blogjava.net/killme2008/archive/2010/09/08/331404.html>

<http://www.cnblogs.com/cj723/archive/2011/04/27/2029993.html>

<http://blog.csdn.net/zuiaituantuan/article/details/5978009>

 

快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。

# 计数排序

计数排序用到一个额外的计数数组C，根据数组C来将原数组A中的元素排到正确的位置。

　　通俗地理解，例如有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性），通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。算法的步骤如下：

1. 统计数组A中每个值A[i]出现的次数，存入C[A[i]]
2. 从前向后，使数组C中的每个值等于其与前一项相加，这样数组C[A[i]]就代表了数组A中小于等于A[i]的元素个数
3. 反向填充目标数组B：将数组元素A[i]放在数组B的第C[A[i]]项（即B[C[A[i]]     - 1]），每放一个元素就将C[A[i]]递减



　　计数排序的实现代码如下：

```
#include<iostream>using namespace std;
```

```
// 分类 ------------ 内部非比较排序// 数据结构 --------- 数组// 最差时间复杂度 ---- O(n + k)// 最优时间复杂度 ---- O(n + k)// 平均时间复杂度 ---- O(n + k)// 最差空间复杂度 ---- O(n + k)
```

```
const int k = 100;   // 基数为100,排序[0,99]内的整数int C[k];            // 计数数组
```

```
void countingsort(int A[], int n)
```

```
{
```

```
    for (int i = 0; i < k; i++)    // 初始化,将数组C中的元素置0(此步骤可省略,整型数组元素默认值为0)    {
```

```
        C[i] = 0;
```

```
    }
```

```
    for (int i = 0; i < n; i++)    // 使C[i]保存着等于i的元素个数    {
```

```
        C[A[i]]++;
```

```
    }
```

```
    for (int i = 1; i < k; i++)    // 使C[i]保存着小于等于i的元素个数,排序后元素i就放在第C[i]个输出位置上    {
```

```
        C[i] = C[i] + C[i - 1];
```

```
    }
```

```
    int *B = (int *)malloc((n)* sizeof(int));// 分配临时空间,长度为n,用来暂存中间数据
```

```
    for (int i = n - 1; i >= 0; i--)　// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)    {                                
```

```
        B[C[A[i]] - 1] = A[i];        // 把每个元素A[i]放到它在输出数组B中的正确位置上
```

```
        C[A[i]]--;                    // 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性    }
```

```
    for (int i = 0; i < n; i++)       // 把临时空间B中的数据拷贝回A    {
```

```
        A[i] = B[i];
```

```
    }
```

```
    free(B);    // 释放临时空间 }
```

```
int main()
```

```
{
```

```
    int A[] = { 15, 22, 19, 46, 27, 73, 1, 19, 8 };  // 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素
```

```
    int n = sizeof(A) / sizeof(int);
```

```
    countingsort(A, n);
```

```
    printf("计数排序结果：");
```

```
    for (int i = 0; i < n; i++)
```

```
    {
```

```
        printf("%d ",A[i]);
```

```
    }
```

```
    printf("\n");
```

```
    return 0;
```

```
}
```

# 基数排序

基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机上的贡献。它是这样实现的：将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。

　　基数排序的实现代码如下：

```
#include<iostream>using namespace std;
```

```
// 分类 -------------- 内部非比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n * dn)// 最差空间复杂度 ---- O(n * dn)
```

```
const int dn = 3;                // 本程序排序的元素为三位数(含以下)const int radix = 10;            // 基数为10,对[0,9]的数字进行计数排序int C[radix];
```

```
int getdigit(int x, int d)            // 获得元素x的第d位数字{
```

```
    int radix[] = { 1, 1, 10, 100 };  // 最大为三位数,所以这里只要到百位就满足了
```

```
    return (x / radix[d]) % 10;
```

```
}
```

```
void countingsort(int A[], int n, int B[], int d)// 应用计数排序(依据元素的第d位数字)对元素排序{
```

```
    for (int i = 0; i < radix; i++)    // 初始化,将数组C中的元素置0    {
```

```
        C[i] = 0;
```

```
    }
```

```
    for (int i = 0; i < n; i++)        // 使C[i]保存着当前位等于i的元素个数    {
```

```
        C[getdigit(A[i], d)]++;
```

```
    }
```

```
    for (int i = 1; i < radix; i++)    // 使C[i]保存着当前位小于等于i的元素个数,排序后元素i就放在第C[i]个输出位置上    {
```

```
        C[i] = C[i] + C[i - 1];
```

```
    }
```

```
    for (int i = n - 1; i >= 0; i--)   // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)    {
```

```
        int j = getdigit(A[i], d);     // 元素A[i]当前位数字为j   
```

```
        B[C[j] - 1] = A[i];            // 根据当前位数字,把每个元素A[i]放到它在输出数组B中的正确位置上
```

```
        C[j]--;                        // 当再遇到当前位数字同为j的元素时,会将其放在当前元素的前一个位置上保证计数排序的稳定性    }
```

```
}
```

```
void lsd_radixsort(int A[], int n)         // 最低位优先基数排序{
```

```
    int *B = (int*)malloc(n * sizeof(int));// 分配临时空间,长度为n,用来暂存中间数据
```

```
    for (int d = 1; d <= dn; d++)          // 从最低位开始到最高位    {
```

```
        countingsort(A, n, B, d);          // 依据第d位调用计数排序
```

```
        for (int i = 0; i < n; i++)        // 把临时空间B中的数据拷贝回A,针对更高位的计数排序在此基础上继续对元素排序        {
```

```
            A[i] = B[i];
```

```
        }
```

```
    }
```

```
    free(B);
```

```
}
```

```
int main()
```

```
{
```

```
    int A[] = { 20, 90, 64, 289, 998, 365, 852, 123, 789, 456 };// 针对基数排序设计的输入
```

```
    int n = sizeof(A) / sizeof(int);
```

```
    lsd_radixsort(A, n);
```

```
    printf("基数排序结果：");
```

```
    for (int i = 0; i < n; i++)
```

```
    {
```

```
        printf("%d ", A[i]);
```

```
    }
```

```
    printf("\n");
```

```
    return 0;
```

```
}
```

# 桶排序

桶排序也叫箱排序。工作的原理是将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。

　　桶排序的实现代码如下：

```
#include<iostream>using namespace std;
```

```
// 分类 ------------- 内部非比较排序// 数据结构 ---------- 数组
```

```
/* 本程序用数组模拟桶 */const int bn = 5;                 // 我们这里打算使用5个桶int C[bn];                        // 计数数组,存放桶的边界信息
```

```
int MapToBucket(int x, int max)   // 把元素x映射到对应的桶中{
```

```
    return (4 * x) / max;         // 返回值范围{0,1,2,3,4},共5个桶}
```

```
void insertionsort(int A[], int left, int right)// 同一个桶内进行插入排序{
```

```
    for (int i = left + 1; i <= right; i++)     // 从桶内第二张牌开始抓,直到最后一张牌    {
```

```
        int get = A[i];
```

```
        int j = i - 1;
```

```
        while (j >= left && A[j] > get)
```

```
        {
```

```
            A[j + 1] = A[j];
```

```
            j--;
```

```
        }
```

```
        A[j + 1] = get;
```

```
    }
```

```
}
```

```
void countingsort(int A[], int n, int B[])// 利用计数排序定位各个桶的边界{
```

```
    for (int i = 0; i < bn; i++)       // 初始化,将数组C中的元素置0    {
```

```
        C[i] = 0;
```

```
    }
```

```
    int max = A[0];
```

```
    for (int i = 1; i < n; i++)        // 获得数组A中元素的最大值,用于把输入元素向桶中映射    {
```

```
        if (A[i] > max)
```

```
            max = A[i];
```

```
    }
```

```
    for (int i = 0; i < n; i++)        // 使C[i]保存着i号桶中元素的个数    {
```

```
        C[MapToBucket(A[i], max)]++;
```

```
    }
```

```
    for (int i = 1; i < bn; i++)       // 定位每个桶的左边界索引：C[i]为i+1号桶中第一个元素的数组下标    {
```

```
        C[i] = C[i] + C[i - 1];
```

```
    }
```

```
    for (int i = n - 1; i >= 0; i--)   // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)    {
```

```
        int j = MapToBucket(A[i], max);// 元素A[i]位于第j号桶
```

```
        B[C[j] - 1] = A[i];            // 把每个元素A[i]放到它在输出数组B中的正确位置上
```

```
        C[j]--;                        // 当再遇到同一个桶中的元素时会被放在当前元素的前一个位置上    }}
```

```
void bucketsort(int A[], int n)
```

```
{
```

```
    int *B = (int *)malloc((n) * sizeof(int)); // 分配临时空间,长度为n,用来暂存中间数据
```

```
    countingsort(A, n, B);       // 应用计数排序把不同桶中的元素排好序，同一桶中的元素暂时按输入次序存放
```

```
    for (int i = 0; i < n; i++)  // 把临时空间B中的数据拷贝回A    {
```

```
        A[i] = B[i];
```

```
    }
```

```
    free(B);                    // 释放临时空间  
```

```
    for (int i = 0; i < bn - 1; i++) // 对同一个桶中的元素应用插入排序,0号筒必定只有一个元素,无需排序    {
```

```
        int left = C[i];         // C[i]为i+1号桶中第一个元素的数组下标
```

```
        int right = C[i + 1] - 1;// C[i+1]-1为i+1号桶中最后一个元素的数组下标   
```

```
        if (left < right)         // 对非空的桶进行桶内排序            insertionsort(A, left, right);
```

```
    }
```

```
}
```

```
int main()
```

```
{
```

```
    int A[] = { 29, 25, 3, 49, 9, 37, 21, 43 };// 针对桶排序设计的输入
```

```
    int n = sizeof(A) / sizeof(int);
```

```
    bucketsort(A, n);
```

```
    printf("桶排序结果：");
```

```
    for (int i = 0; i < n; i++)
```

```
    {
```

```
        printf("%d ", A[i]);
```

```
    }
```

```
    printf("\n");
```

```
    return 0;
```

```
}
```

 

 