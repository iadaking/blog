---
typora-copy-images-to: ..\img
---

[TOC]
# 第2章 Java内存区域与内存溢出异常

## 2.1 概述

Java程序员不用再为内存管理而烦恼，但是将内存控制权利交给Java虚拟机来管理，一但出现内存泄漏方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查工作将十分的艰难。

## 2.2 运行时数据区域

随着虚拟机进程的启动而存在，由所有线程共享的数据区域

- 方法区
- 堆

以下区域随着用户线程的启动和结束而建立和销毁，线程隔离的数据区域

- 程序计数器
- 虚拟机栈
- 本地方法栈

### 2.2.1 程序计数器

每个线程都有一个独立的线程计数器，这块内存称为线程私有的内存区域。

程序计数器内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### 2.2.2 Java虚拟机栈

Java虚拟机栈是线程私有的区域，他的生命周期与线程相同。Java虚拟机栈的栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

局部变量表存放了编译期可知的各种基本数据类型（boolean、char、byte、short、int、long、float、double）、对象引用、returnAddress类型。

如果线程请求的栈深度大于虚拟机所允许的深度时，将抛出StackOverflowError异常。当虚拟机栈动态扩展时，若无法申请到足够的内存，就会抛出OutOfMemoryError异常。

### 2.2.3 本地方法栈

虚拟机栈为虚拟机执行Java方法服务，本地方法栈则为虚拟机使用到的Native方法服务。本地方法栈区域也会抛出`StackOverflowError`和`OutOfMemoryError`异常。

### 2.2.4 Java堆

内存区域最大，Java堆是被所有线程共享的一块内存区域，虚拟机启动时创建，此内存区域用来存放对象实例。

Java堆是垃圾收集器管理的主要区域，可以细分为：新生代和老年代。

Java堆只需要逻辑上连续即可，物理上可以处于不连续的内存空间中。Java堆大小的扩展可以通过 `-Xmx` 和 `-Xms` 控制。如果堆中没有内存完成实例分配，并且也无法再扩展时，将会抛出 `OutOfMemoryError` 异常。

### 2.2.5 方法区

方法区和堆一样都是线程共享的内存区域，方法区存储了已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

### 2.2.6 运行时常量池

运行时常量池是方法区的一部分， Class 文件中有一项常量池，用于存放编译期生成的各种字面量和符号引用，该内容在类加载后进入方法区运行时常量池中存放。

一般来说，Class 文件中描述的符号引用和翻译出来的直接引用也会存在运行时常量池中。

运行时常量池具备动态性，运行期间也可能将新的常量放入池中，这种特性的被利用的较多便是 String 类的 intern() 方法。

当常量池无法申请到内存时会抛出 OutOfMemoryError 异常。

### 2.2.7 直接内存

