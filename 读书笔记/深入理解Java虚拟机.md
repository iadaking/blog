[TOC]

# 第2章 Java内存区域与内存溢出异常

## 2.1 概述

Java程序员不用再为内存管理而烦恼，但是将内存控制权利交给Java虚拟机来管理，一但出现内存泄漏方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查工作将十分的艰难。

## 2.2 运行时数据区域

随着虚拟机进程的启动而存在，由所有线程共享的数据区域

- 方法区
- 堆

以下区域随着用户线程的启动和结束而建立和销毁，线程隔离的数据区域

- 程序计数器
- 虚拟机栈
- 本地方法栈

### 2.2.1 程序计数器

每个线程都有一个独立的线程计数器，这块内存称为线程私有的内存区域。

程序计数器内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### 2.2.2 Java虚拟机栈

Java虚拟机栈是线程私有的区域，他的生命周期与线程相同。Java虚拟机栈的栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

局部变量表存放了编译期可知的各种基本数据类型（boolean、char、byte、short、int、long、float、double）、对象引用、returnAddress类型。

如果线程请求的栈深度大于虚拟机所允许的深度时，将抛出StackOverflowError异常。当虚拟机栈动态扩展时，若无法申请到足够的内存，就会抛出OutOfMemoryError异常。

### 2.2.3 本地方法栈

虚拟机栈为虚拟机执行Java方法服务，本地方法栈则为虚拟机使用到的Native方法服务。本地方法栈区域也会抛出`StackOverflowError`和`OutOfMemoryError`异常。

### 2.2.4 Java堆

内存区域最大，Java堆是被所有线程共享的一块内存区域，虚拟机启动时创建，此内存区域用来存放对象实例。

Java堆是垃圾收集器管理的主要区域，可以细分为：新生代和老年代。

Java堆只需要逻辑上连续即可，物理上可以处于不连续的内存空间中。Java堆大小的扩展可以通过 `-Xmx` 和 `-Xms` 控制。如果堆中没有内存完成实例分配，并且也无法再扩展时，将会抛出 `OutOfMemoryError` 异常。



